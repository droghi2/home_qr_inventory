<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ title }}</title>
  <meta name="theme-color" content="#2563eb">
  <link rel="stylesheet" href="/static/style.css">
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml">
  <meta name="theme-color" content="#2563eb">
<style>
  .icon-btn { display:inline-flex; align-items:center; justify-content:center; width:32px; height:32px; padding:0; }
  .ico { width:18px; height:18px; display:inline-block; vertical-align:middle; }
  .btn-with-icon { display:inline-flex; align-items:center; gap:8px; }
  .icon-btn img { pointer-events:none; } /* don’t steal clicks */
</style>
<style>
  .header-inner{display:flex;align-items:center;gap:12px;padding:8px 12px}
  .brand{display:flex;align-items:center;gap:8px;min-width:0}
  .header-search{display:flex;align-items:center;gap:6px;flex:1;min-width:0}
  .header-search input{flex:1;min-width:0}
  .header-search .icon-btn{flex:0 0 auto}
  .menu-wrap{position:relative}
  /* Opaque dropdown (no glass) */
  .menu-dropdown{
    position: absolute;
    right: 0;
    top: calc(100% + 6px);
    min-width: 180px;

    /* solid background + crisp border */
    background: #0b1220 !important;
    color: #e6eefb;
    border: 1px solid #1e293b;
    border-radius: 10px;

    /* stronger shadow, no blur */
    box-shadow: 0 14px 30px rgba(0,0,0,.45), 0 2px 8px rgba(0,0,0,.25);
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;

    padding: 6px;
    z-index: 1000;
  }

  .menu-item{
    display: block;
    padding: 8px 10px;
    border-radius: 6px;
    text-decoration: none;
    color: #e6eefb;             /* readable on dark */
  }

  .menu-item:hover{
    background: rgba(255,255,255,.06); /* subtle hover on dark */
  }
    @media (max-width:640px){
      .header-inner{gap:8px}
      .brand div:last-child{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:45vw}
    }
</style>
<style>
  /* Menu button = same look as the emoji logo tile */
  #menuBtn{
    width: 36px; height: 36px; border-radius: 10px;
    display: grid; place-items: center;
    background: linear-gradient(135deg, #6bb8ff 0%, #4ea1ff 45%, #3b7cff 100%);
    color: #0b1220;
    border: none;
    box-shadow:
      0 8px 18px rgba(78,161,255,.35),
      0 0 0 1px rgba(78,161,255,.35) inset;
    transition: transform .18s ease, filter .18s ease, box-shadow .18s ease;
  }
  #menuBtn:hover{
    transform: translateY(-1px);
    filter: brightness(1.05);
  }
  #menuBtn:active{
    transform: translateY(1px);
    filter: brightness(.98);
  }
  #menuBtn:focus-visible{
    outline: none;
    box-shadow:
      0 0 0 3px rgba(78,161,255,.45),
      0 8px 18px rgba(78,161,255,.35),
      0 0 0 1px rgba(78,161,255,.35) inset;
  }
</style>

<style>
  /* already have .header-inner, .brand from earlier snippet */
  @media (max-width: 640px){
    .brand > :nth-child(2){ display:none; }   /* hide the title, keep the logo */
    .header-inner{ gap: 8px; }
  }
  /* logo container */
.header-inner .logo{
  width: 36px; height: 36px; border-radius: 10px;
  display:grid; place-items:center;
  /* remove the emoji tile gradient since we're showing your image now */
  background: transparent;
  box-shadow: none;
  transition: transform .18s ease, filter .18s ease;
}
.header-inner .logo:hover{ transform: translateY(-1px); filter: brightness(1.05); }

/* make the image fit nicely */
.header-inner .logo picture,
.header-inner .logo img{
  width: 100%; height: 100%;
  display: block;
  object-fit: contain;      /* preserves aspect ratio */
  border-radius: 10px;      /* round corners if your image is square */
}

/* keep your title text styling as before */
.header-inner .brand > .brand-text{
  font-size: 1.02rem;
  color: var(--text);
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
}

/* mobile: hide the brand text, show just the icon + controls */
@media (max-width: 640px){
  .header-inner .brand > .brand-text{ display:none; }
}
/* make all modals layered */
.modal{ position: fixed; inset: 0; z-index: 1000; }

/* force the QR scanner to be on top of any page modal */
#qrScanModal{ z-index: 4000; }

</style>

<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
</head>
<body>
  <header>
    <div class="header-inner">
      <div class="brand">
        <div class="brand">
          <a class="logo" href="/" aria-label="Home" title="Home">
            <picture>
              <!-- prefer your dedicated logo first -->
              <source srcset="/static/favicon.svg" type="image/svg+xml">
              <!-- fallback if you only have a PNG -->
              <img src="/static/logo.png"
                  alt="Home QR Inventory"
                  width="36" height="36"
                  loading="eager" decoding="async">
            </picture>
          </a>
          <div class="brand-text">Home QR Inventory</div>
        </div>
      </div>

      <!-- Global search (always visible, submits to /) -->
      <form class="header-search" method="get" action="/" role="search" aria-label="Search">
        <input type="text" name="q" placeholder="Search containers/items…" value="{{ q or '' }}" aria-label="Search query">
        <button class="icon-btn" title="Search" aria-label="Search">
          <img src="/static/W_Search_Icon.png" alt="" width="22" height="22" decoding="async" draggable="false">
        </button>
      </form>
      <!-- Mobile-only QR scan button -->
      <button id="qrBtn" class="tile-btn only-mobile" title="Scan QR" aria-label="Scan QR">
          <img src="/static/QR_Icon.png" alt="" width="22" height="22" decoding="async" draggable="false">
      </button>

      <!-- Rightmost menu -->
      <div class="menu-wrap">
        <button id="menuBtn" class="icon-btn glow" title="Menu" aria-haspopup="true" aria-expanded="false">⋮</button>
        <div id="menuDropdown" class="menu-dropdown card" hidden>
          <a class="menu-item" href="/types">Item Types</a>
          <a class="menu-item" href="/install-certificate">HTTPS</a>

        </div>
      </div>
    </div>
  </header>



  <div class="container">
    <main>

      <div id="confirmModal" class="modal modal-small" style="display:none">
        <div class="modal-content card">
          <div class="card-pad">
            <h3 class="kicker" id="confirmTitle">Confirm delete</h3>
            <p id="confirmMsg" class="muted" style="margin:.6rem 0 1rem 0"></p>
            <div class="row" style="gap:8px; justify-content:flex-end;">
              <button type="button" class="ghost" id="confirmCancel">Cancel</button>
              <button type="button" class="danger" id="confirmOk">Delete</button>
            </div>
          </div>
        </div>
      </div>

      <!-- QR Scan Modal -->
      <div id="qrScanModal" class="modal" style="display:none">
        <div class="modal-content card" style="max-width:640px;width:100%;">
          <div class="card-pad">
            <h3 id="qrTitle" class="kicker" style="margin:0 0 .25rem 0;">Scan a QR</h3>
            <p id="qrHelp" class="muted" style="margin:.1rem 0 .5rem 0; display:none;"></p>


            <div class="qr-video-wrap">
              <video id="qrVideo" playsinline webkit-playsinline muted autoplay></video>

              <canvas id="qrCanvas" style="display:none"></canvas>
              <!-- scanning guide -->
              <div class="qr-guide"></div>
            </div>

            <!-- Controls bar -->
            <div class="qr-controls">

              <div class="row" style="gap:8px;align-items:center;">
                <button type="button" id="qrTorchBtn" class="icon-btn ghost" title="Toggle light" aria-label="Toggle light">
                  <img src="/static/W_Torch.png" alt="" width="22" height="22" decoding="async" draggable="false">
                </button>
                <button type="button" id="qrSwitchBtn" class="icon-btn ghost" title="Switch camera" aria-label="Switch camera">
                  <img src="/static/W_SwitchCam.png" alt="" width="22" height="22" decoding="async" draggable="false">
                </button>
                <span id="qrStatus" class="muted">Point your camera at a code…</span>
              </div>

              <button type="button" id="qrCloseBtn" class="icon-btn ghost" title="Close" aria-label="Close">
                <img src="/static/W_Close.png" alt="" width="20" height="20" decoding="async" draggable="false">
              </button>
            </div>



          </div>
        </div>
      </div>



      {% block content %}{% endblock %}
    </main>
    <footer class="section muted">
      <hr>
      <div class="kicker">Cabinet/Wardrobe → Shelf/Drawer → Container → Items</div>
      <link rel="stylesheet" href="/static/style.css?v=footer1">

    </footer>

  </div>
</body>
<script>
/* ===== Menu dropdown (no src inside this tag) ===== */
(() => {
  const wrap = document.querySelector('.menu-wrap');
  const btn  = document.getElementById('menuBtn');
  const dd   = document.getElementById('menuDropdown');
  if (!wrap || !btn || !dd) return;

  function open(){ dd.hidden = false; btn.setAttribute('aria-expanded','true'); }
  function close(){ dd.hidden = true;  btn.setAttribute('aria-expanded','false'); }

  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    dd.hidden ? open() : close();
  });

  document.addEventListener('click', (e) => {
    if (!wrap.contains(e.target)) close();
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
  });
})();
</script>

<script>
(() => {
  const modal     = document.getElementById('qrScanModal');
  const video     = document.getElementById('qrVideo');
  const canvas    = document.getElementById('qrCanvas');
  const ctx       = canvas.getContext('2d', { willReadFrequently: true });
  const statusEl  = document.getElementById('qrStatus');
  const closeBtn  = document.getElementById('qrCloseBtn');
  const torchBtn  = document.getElementById('qrTorchBtn');
  const switchBtn = document.getElementById('qrSwitchBtn');   // ← NEW (optional)

  // header/menu buttons (if present)
  const openBtns  = [document.getElementById('qrBtn'), document.getElementById('scanQrMenu')].filter(Boolean);
  // optional: a button inside other modals you may wire up by setting window.qrScanHook before opening
  const moveScanBtn = document.getElementById('moveScanBtn');

  let scanning = false;
  let handled  = false;
  let cams = [], camIdx = -1;
  let detector = null;
  let torchOn = false;
  let _hiddenModals = [];
  let scanCtx = { title: 'Scan a QR', help: 'Point your camera at a code…', onResult: null };


  // Race-proof shutdown / start
  let loopController = null;   // AbortController for scan loop
  let openToken = 0;           // increments on every open/close to invalidate late getUserMedia
  let currentStream = null;    // keep a handle to stop tracks reliably

  if ('BarcodeDetector' in window) {
    try { detector = new BarcodeDetector({ formats: ['qr_code'] }); } catch {}
  }

  // ---------- helpers ----------
  function extractContainerId(s) {
    const m = String(s).toUpperCase().match(/\b[0-9A-F]{8}\b/);
    return m ? m[0] : null;
  }

  async function listCams() {
    try {
      const devs = await navigator.mediaDevices.enumerateDevices();
      cams = devs.filter(d => d.kind === 'videoinput');
      if (camIdx === -1 && cams.length) camIdx = 0;
    } catch { cams = []; camIdx = -1; }
    // Show switch button only if we have more than one camera
    if (switchBtn) switchBtn.hidden = !(cams && cams.length > 1);
  }

  function isBackLabel(label='') {
    const l = label.toLowerCase();
    return /back|rear|environment/.test(l);
  }

  function getActiveVideoTrack() {
    const s = video?.srcObject;
    if (!s) return null;
    const tracks = s.getVideoTracks();
    return tracks.length ? tracks[0] : null;
  }

  function setupTorchUI() {
    const track = getActiveVideoTrack();
    torchOn = false;
    if (!torchBtn) return;
    if (!track) { torchBtn.hidden = true; return; }
    const caps = track.getCapabilities ? track.getCapabilities() : {};
    torchBtn.hidden = !('torch' in caps);
  }

  async function toggleTorch() {
    const track = getActiveVideoTrack();
    if (!track || !track.applyConstraints) return;
    const caps = track.getCapabilities ? track.getCapabilities() : {};
    if (!('torch' in caps)) return;
    torchOn = !torchOn;
    try { await track.applyConstraints({ advanced: [{ torch: torchOn }] }); } catch {}
  }

  function stopStream() {
    try {
      const s = currentStream || video.srcObject;
      if (s) s.getTracks().forEach(t => { try { t.stop(); } catch {} });
    } catch {}
    currentStream = null;

    // iOS/Safari: extra steps to fully release the camera
    try { video.pause(); } catch {}
    try { video.srcObject = null; } catch {}
    try { video.removeAttribute('src'); video.load(); } catch {}
  }

  async function waitForVideoReady(v) {
    if (v.readyState >= 2 && v.videoWidth && v.videoHeight) return;
    await new Promise(res => { const h=()=>{ v.onloadedmetadata=null; res(); }; v.onloadedmetadata = h; });
    for (let i=0; i<10 && (!v.videoWidth || !v.videoHeight); i++) {
      await new Promise(r => setTimeout(r, 50));
    }
  }

  function hideOtherModals(){
    _hiddenModals = [];
    ['moveItemModal','moveContainerModal','addItemModal','editItemModal','confirmModal'].forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      const visible = getComputedStyle(el).display !== 'none';
      if (visible){ _hiddenModals.push(el); el.style.display = 'none'; }
    });
  }
  function restoreHiddenModals(){ _hiddenModals.forEach(el => el.style.display='flex'); _hiddenModals = []; }

  async function tryGetUserMedia(constraints) {
    try { return await navigator.mediaDevices.getUserMedia(constraints); }
    catch { return null; }
  }

  // === Start camera by specific deviceId (used by switch button)
  async function startCameraByDeviceId(myToken, deviceId){
    stopStream();

    const insecure = location.protocol !== 'https:' && location.hostname !== 'localhost';
    if (insecure) { statusEl && (statusEl.textContent = 'Needs HTTPS (or http://localhost) for camera.'); return; }

    const stream = await tryGetUserMedia({
      video: { deviceId: { exact: deviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } },
      audio: false
    });

    if (myToken !== openToken || !modal || getComputedStyle(modal).display === 'none') {
      if (stream) { try { stream.getTracks().forEach(t=>t.stop()); } catch {} }
      return;
    }

    if (!stream) { statusEl && (statusEl.textContent = 'Could not start camera.'); return; }

    currentStream = stream;
    video.srcObject = stream;
    try { await video.play(); } catch {}

    await waitForVideoReady(video);
    canvas.width  = video.videoWidth  || 640;
    canvas.height = video.videoHeight || 480;

    setupTorchUI();

    statusEl && (statusEl.textContent = 'Point camera at a code…');
    handled = false;
    scanning = true;

    loopController?.abort();
    loopController = new AbortController();
    scanLoop(loopController.signal, myToken);
  }

  // === Race-proof camera start. Prefers back camera.
  async function startCameraPreferredBack(myToken) {
    stopStream();

    const insecure = location.protocol !== 'https:' && location.hostname !== 'localhost';
    if (insecure) {
      if (statusEl) statusEl.textContent = 'Needs HTTPS (or http://localhost) for camera.';
      return;
    }

    const attempts = [
      { video: { facingMode: { exact: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false },
      { video: { facingMode: { ideal: 'environment' },  width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false },
      { video: true }
    ];

    let stream = null;
    for (const c of attempts) {
      stream = await tryGetUserMedia(c);
      if (stream) break;
    }

    // Modal may have been closed while getUserMedia was pending
    if (myToken !== openToken || !modal || getComputedStyle(modal).display === 'none') {
      if (stream) { try { stream.getTracks().forEach(t => t.stop()); } catch {} }
      return;
    }

    if (!stream) {
      if (statusEl) statusEl.textContent = 'Could not start camera.';
      return;
    }

    currentStream = stream;
    video.srcObject = stream;
    try { await video.play(); } catch {}

    // After permission, labels become available
    await listCams();
    const currentTrack = getActiveVideoTrack();
    const sett = currentTrack?.getSettings?.() || {};
    const alreadyBack = (sett.facingMode || '').toLowerCase() === 'environment';

    if (!alreadyBack && cams.length) {
      const rear = cams.find(d => isBackLabel(d.label)) || cams.find(d => /camera\s*[\d]/i.test(d.label));
      if (rear && rear.deviceId && rear.deviceId !== sett.deviceId) {
        if (myToken !== openToken) { stopStream(); return; }
        stopStream();
        const s2 = await tryGetUserMedia({
          video: { deviceId: { exact: rear.deviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: false
        });
        if (myToken !== openToken) { if (s2) { try { s2.getTracks().forEach(t=>t.stop()); } catch {} } return; }
        if (s2) {
          currentStream = s2;
          video.srcObject = s2;
          try { await video.play(); } catch {}
        } else {
          currentStream = stream;
          video.srcObject = stream;
          try { await video.play(); } catch {}
        }
      }
    }

    if (myToken !== openToken) { stopStream(); return; }

    await waitForVideoReady(video);

    canvas.width  = video.videoWidth  || 640;
    canvas.height = video.videoHeight || 480;

    setupTorchUI();

    if (statusEl) statusEl.textContent = 'Point camera at a QR…';
    handled = false;
    scanning = true;

    loopController?.abort();
    loopController = new AbortController();
    scanLoop(loopController.signal, myToken);
  }

  async function scanLoop(signal, myToken){
    while (!signal.aborted && scanning && myToken === openToken) {
      try{
        if (detector) {
          const res = await detector.detect(video);
          if (res && res.length) {
            for (const r of res) {
              const id = extractContainerId(r.rawValue);
              if (id) return onResult(id);
            }
          }
        }

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
        if (window.jsQR) {
          const code = jsQR(img.data, img.width, img.height, { inversionAttempts: 'attemptBoth' });
          if (code) {
            const id = extractContainerId(code.data);
            if (id) return onResult(id);
          }
        }
      }catch(_){}

      await new Promise(r => setTimeout(r, 100));
    }
  }

  function onResult(id){
    scanning = false;
    loopController?.abort();
    if (statusEl) statusEl.textContent = 'Got code: ' + id;

    if (typeof scanCtx.onResult === 'function') {
      try { scanCtx.onResult(id); } finally { scanCtx.onResult = null; }
      return;
    }
    if (window.qrScanHook) {
      const cb = window.qrScanHook; window.qrScanHook = null;
      try { cb(id); } finally {}
      return;
    }
    location.href = '/container/' + id;
  }


  async function openModal(opts = {}){
    // merge defaults
    scanCtx.title = opts.title || 'Scan a QR';
    scanCtx.help  = opts.help  || 'Point your camera at a code…';
    scanCtx.onResult = typeof opts.onResult === 'function' ? opts.onResult : null;

    // set UI texts
    const titleEl = document.getElementById('qrTitle');
    const helpEl  = document.getElementById('qrHelp');
    if (titleEl) titleEl.textContent = scanCtx.title;
    if (helpEl)  { helpEl.textContent = scanCtx.help; helpEl.style.display = scanCtx.help ? '' : 'none'; }
    if (statusEl) statusEl.textContent = scanCtx.help || 'Point your camera at a code…';

    const myToken = ++openToken;

    hideOtherModals();
    modal.style.zIndex = '5000';
    const dd = document.getElementById('menuDropdown');
    if (dd && !dd.hidden) dd.hidden = true;

    modal.style.display = 'flex';

    try {
      await listCams();                          // ← ensures switchBtn visibility is correct
      await startCameraPreferredBack(myToken);
    } catch (err) {
      console.warn(err);
      if (statusEl) statusEl.textContent = 'Could not start camera. Check permissions/HTTPS.';
    }
  }

  async function closeModal(){
    ++openToken;                 // Invalidate any late getUserMedia / loops
    scanning = false;
    loopController?.abort();
    stopStream();

    modal.style.display = 'none';
    await new Promise(r => setTimeout(r, 50));   // give mobile a moment to release camera

    restoreHiddenModals();
    window.dispatchEvent(new Event('qr_scanner_closed'));
  }

  // export controls
  window.openQrScanner  = (opts) => openModal(opts || {});
  window.closeQrScanner = closeModal;

  // handy helpers you can call anywhere:
  window.openQrForMoveItem = (itemName) =>
    openModal({
      title: `Move item${itemName ? `: ${itemName}` : ''}`,
      help:  `Scan the destination container’s QR label.`,
    });

  window.openQrForMoveContainer = (contName) =>
    openModal({
      title: `Move container${contName ? `: ${contName}` : ''}`,
      help:  `Scan ANY container on the target shelf/drawer you want to move this into.`,
    });


  // wire up
  openBtns.forEach(btn => btn.addEventListener('click', (e)=>{ e.preventDefault(); openModal(); }));
  closeBtn?.addEventListener('click', closeModal);
  modal?.addEventListener('click', (e)=>{ if (e.target === modal) closeModal(); });
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && getComputedStyle(modal).display === 'flex') closeModal(); });
  torchBtn?.addEventListener('click', toggleTorch);

  // Switch camera click: cycle through available devices
  switchBtn?.addEventListener('click', async () => {
    if (!(cams && cams.length > 1)) return;
    const myToken = ++openToken;

    // active device
    const track = getActiveVideoTrack();
    let currId = track?.getSettings?.().deviceId || null;

    // ensure fresh list
    await listCams();

    let idx = currId ? cams.findIndex(d => d.deviceId === currId) : -1;
    idx = (idx < 0) ? 0 : idx;
    const next = cams[(idx + 1) % cams.length];
    if (!next) return;

    await startCameraByDeviceId(myToken, next.deviceId);
  });

  // Also shut down if the tab is hidden or page is going away
  window.addEventListener('visibilitychange', ()=>{ if (document.hidden && getComputedStyle(modal).display === 'flex') closeModal(); });
  window.addEventListener('pagehide', ()=>{ if (getComputedStyle(modal).display === 'flex') closeModal(); });
  window.addEventListener('beforeunload', ()=>{ if (getComputedStyle(modal).display === 'flex') closeModal(); });

  // optional: example of hooking a scan button elsewhere
  if (moveScanBtn){
    moveScanBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      window.qrScanHook = (id) => {
        try{
          const select = document.querySelector('#moveItemModal select[name="dest_container_id"]');
          if (select){
            let opt = Array.from(select.options).find(o => o.value === id);
            if (!opt){
              opt = document.createElement('option');
              opt.value = id;
              opt.textContent = `#${id} (scanned)`;
              select.prepend(opt);
            }
            select.value = id;
          }
          const form = document.getElementById('moveItemForm');
          if (form) form.submit();
        } finally { closeModal(); }
      };
      openModal();
    });
  }
})();
</script>






</html>