<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ title }}</title>
  <meta name="theme-color" content="#2563eb">
  <link rel="stylesheet" href="/static/style.css">
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml">
  <meta name="theme-color" content="#2563eb">
<style>
  .header-inner{display:flex;align-items:center;gap:12px;padding:8px 12px}
  .brand{display:flex;align-items:center;gap:8px;min-width:0}
  .header-search{display:flex;align-items:center;gap:6px;flex:1;min-width:0}
  .header-search input{flex:1;min-width:0}
  .header-search .icon-btn{flex:0 0 auto}
  .menu-wrap{position:relative}
  /* Opaque dropdown (no glass) */
  .menu-dropdown{
    position: absolute;
    right: 0;
    top: calc(100% + 6px);
    min-width: 180px;

    /* solid background + crisp border */
    background: #0b1220 !important;
    color: #e6eefb;
    border: 1px solid #1e293b;
    border-radius: 10px;

    /* stronger shadow, no blur */
    box-shadow: 0 14px 30px rgba(0,0,0,.45), 0 2px 8px rgba(0,0,0,.25);
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;

    padding: 6px;
    z-index: 1000;
  }

  .menu-item{
    display: block;
    padding: 8px 10px;
    border-radius: 6px;
    text-decoration: none;
    color: #e6eefb;             /* readable on dark */
  }

  .menu-item:hover{
    background: rgba(255,255,255,.06); /* subtle hover on dark */
  }
    @media (max-width:640px){
      .header-inner{gap:8px}
      .brand div:last-child{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:45vw}
    }
</style>
<style>
  /* Menu button = same look as the emoji logo tile */
  #menuBtn{
    width: 36px; height: 36px; border-radius: 10px;
    display: grid; place-items: center;
    background: linear-gradient(135deg, #6bb8ff 0%, #4ea1ff 45%, #3b7cff 100%);
    color: #0b1220;
    border: none;
    box-shadow:
      0 8px 18px rgba(78,161,255,.35),
      0 0 0 1px rgba(78,161,255,.35) inset;
    transition: transform .18s ease, filter .18s ease, box-shadow .18s ease;
  }
  #menuBtn:hover{
    transform: translateY(-1px);
    filter: brightness(1.05);
  }
  #menuBtn:active{
    transform: translateY(1px);
    filter: brightness(.98);
  }
  #menuBtn:focus-visible{
    outline: none;
    box-shadow:
      0 0 0 3px rgba(78,161,255,.45),
      0 8px 18px rgba(78,161,255,.35),
      0 0 0 1px rgba(78,161,255,.35) inset;
  }
</style>

<style>
  /* already have .header-inner, .brand from earlier snippet */
  @media (max-width: 640px){
    .brand > :nth-child(2){ display:none; }   /* hide the title, keep the logo */
    .header-inner{ gap: 8px; }
  }
  /* logo container */
.header-inner .logo{
  width: 36px; height: 36px; border-radius: 10px;
  display:grid; place-items:center;
  /* remove the emoji tile gradient since we're showing your image now */
  background: transparent;
  box-shadow: none;
  transition: transform .18s ease, filter .18s ease;
}
.header-inner .logo:hover{ transform: translateY(-1px); filter: brightness(1.05); }

/* make the image fit nicely */
.header-inner .logo picture,
.header-inner .logo img{
  width: 100%; height: 100%;
  display: block;
  object-fit: contain;      /* preserves aspect ratio */
  border-radius: 10px;      /* round corners if your image is square */
}

/* keep your title text styling as before */
.header-inner .brand > .brand-text{
  font-size: 1.02rem;
  color: var(--text);
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
}

/* mobile: hide the brand text, show just the icon + controls */
@media (max-width: 640px){
  .header-inner .brand > .brand-text{ display:none; }
}
/* make all modals layered */
.modal{ position: fixed; inset: 0; z-index: 1000; }

/* force the QR scanner to be on top of any page modal */
#qrScanModal{ z-index: 4000; }

</style>

<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
</head>
<body>
  <header>
    <div class="header-inner">
      <div class="brand">
        <div class="brand">
          <a class="logo" href="/" aria-label="Home" title="Home">
            <picture>
              <!-- prefer your dedicated logo first -->
              <source srcset="/static/favicon.svg" type="image/svg+xml">
              <!-- fallback if you only have a PNG -->
              <img src="/static/logo.png"
                  alt="Home QR Inventory"
                  width="36" height="36"
                  loading="eager" decoding="async">
            </picture>
          </a>
          <div class="brand-text">Home QR Inventory</div>
        </div>
      </div>

      <!-- Global search (always visible, submits to /) -->
      <form class="header-search" method="get" action="/" role="search" aria-label="Search">
        <input type="text" name="q" placeholder="Search containers/items‚Ä¶" value="{{ q or '' }}" aria-label="Search query">
        <button class="icon-btn" title="Search" aria-label="Search">üîç</button>
      </form>
      <!-- Mobile-only QR scan button -->
      <button id="qrBtn" class="tile-btn only-mobile" title="Scan QR" aria-label="Scan QR">üì∑</button>

      <!-- Rightmost menu -->
      <div class="menu-wrap">
        <button id="menuBtn" class="icon-btn glow" title="Menu" aria-haspopup="true" aria-expanded="false">‚ãÆ</button>
        <div id="menuDropdown" class="menu-dropdown card" hidden>
          <a class="menu-item" href="/types">Item Types</a>
          <button type="button" class="menu-item" id="scanQrMenu">Scan QR</button>
          <a class="menu-item" href="/install-certificate">Install on phone/PC</a>

        </div>
      </div>
    </div>
  </header>



  <div class="container">
    <main>

      <div id="confirmModal" class="modal modal-small" style="display:none">
        <div class="modal-content card">
          <div class="card-pad">
            <h3 class="kicker" id="confirmTitle">Confirm delete</h3>
            <p id="confirmMsg" class="muted" style="margin:.6rem 0 1rem 0"></p>
            <div class="row" style="gap:8px; justify-content:flex-end;">
              <button type="button" class="ghost" id="confirmCancel">Cancel</button>
              <button type="button" class="danger" id="confirmOk">Delete</button>
            </div>
          </div>
        </div>
      </div>

      <!-- QR Scan Modal -->
      <div id="qrScanModal" class="modal" style="display:none">
        <div class="modal-content card" style="max-width:640px;width:100%;">
          <div class="card-pad">
            <h3 class="kicker" style="margin:0 0 .4rem 0;">Scan a QR</h3>

            <div class="qr-video-wrap">
              <video id="qrVideo" playsinline webkit-playsinline muted autoplay></video>

              <canvas id="qrCanvas" style="display:none"></canvas>
              <!-- scanning guide -->
              <div class="qr-guide"></div>
            </div>

            <div class="row" style="gap:8px;justify-content:space-between;margin-top:.6rem;">
              <div class="row" style="gap:8px;">
                <button type="button" id="qrTorchBtn" class="ghost" style="display:none;">Toggle light</button>
                <span id="qrStatus" class="muted">Point your camera at a code‚Ä¶</span>
              </div>
              <button type="button" id="qrCloseBtn" class="ghost">Close</button>
            </div>
          </div>
        </div>
      </div>



      {% block content %}{% endblock %}
    </main>
    <footer class="section muted">
      <hr>
      <div class="kicker">Cabinet/Wardrobe ‚Üí Shelf/Drawer ‚Üí Container ‚Üí Items</div>
      <link rel="stylesheet" href="/static/style.css?v=footer1">

    </footer>

  </div>
</body>
<script>
/* ===== Menu dropdown (no src inside this tag) ===== */
(() => {
  const wrap = document.querySelector('.menu-wrap');
  const btn  = document.getElementById('menuBtn');
  const dd   = document.getElementById('menuDropdown');
  if (!wrap || !btn || !dd) return;

  function open(){ dd.hidden = false; btn.setAttribute('aria-expanded','true'); }
  function close(){ dd.hidden = true;  btn.setAttribute('aria-expanded','false'); }

  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    dd.hidden ? open() : close();
  });

  document.addEventListener('click', (e) => {
    if (!wrap.contains(e.target)) close();
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') close();
  });
})();
</script>

<script>
(() => {
  const modal     = document.getElementById('qrScanModal');
  const video     = document.getElementById('qrVideo');
  const canvas    = document.getElementById('qrCanvas');
  const ctx       = canvas.getContext('2d', { willReadFrequently: true });
  const statusEl  = document.getElementById('qrStatus');
  const closeBtn  = document.getElementById('qrCloseBtn');
  const torchBtn  = document.getElementById('qrTorchBtn');

  // header/menu buttons (if present)
  const openBtns  = [document.getElementById('qrBtn'), document.getElementById('scanQrMenu')].filter(Boolean);
  // optional: a button inside other modals you may wire up by setting window.qrScanHook before opening
  const moveScanBtn = document.getElementById('moveScanBtn');

  let scanning = false;
  let handled  = false;
  let cams = [], camIdx = -1;
  let detector = null;
  let torchOn = false;
  let _hiddenModals = [];

  if ('BarcodeDetector' in window) {
    try { detector = new BarcodeDetector({ formats: ['qr_code'] }); } catch {}
  }

  // ---------- helpers ----------
  function extractContainerId(s) {
    const m = String(s).toUpperCase().match(/\b[0-9A-F]{8}\b/);
    return m ? m[0] : null;
  }

  async function listCams() {
    const devs = await navigator.mediaDevices.enumerateDevices();
    cams = devs.filter(d => d.kind === 'videoinput');
    if (camIdx === -1 && cams.length) camIdx = 0;
  }

  function isBackLabel(label='') {
    const l = label.toLowerCase();
    return /back|rear|environment/.test(l);
  }

  function stopStream() {
    const s = video?.srcObject;
    if (s) s.getTracks().forEach(t => t.stop());
    if (video) video.srcObject = null;
  }

  async function waitForVideoReady(v) {
    if (v.readyState >= 2 && v.videoWidth && v.videoHeight) return;
    await new Promise(r => { const h=()=>{ v.onloadedmetadata=null; r(); }; v.onloadedmetadata = h; });
    for (let i=0; i<10 && (!v.videoWidth || !v.videoHeight); i++) {
      await new Promise(r => setTimeout(r, 50));
    }
  }

  function hideOtherModals(){
    _hiddenModals = [];
    ['moveItemModal','moveContainerModal','addItemModal','editItemModal','confirmModal'].forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      const visible = getComputedStyle(el).display !== 'none';
      if (visible){ _hiddenModals.push(el); el.style.display = 'none'; }
    });
  }
  function restoreHiddenModals(){ _hiddenModals.forEach(el => el.style.display='flex'); _hiddenModals = []; }

  function getActiveVideoTrack() {
    const s = video?.srcObject;
    if (!s) return null;
    const tracks = s.getVideoTracks();
    return tracks.length ? tracks[0] : null;
  }

  function setupTorchUI() {
    const track = getActiveVideoTrack();
    torchOn = false;
    if (!torchBtn) return;
    if (!track) { torchBtn.style.display='none'; return; }
    const caps = track.getCapabilities ? track.getCapabilities() : {};
    if (caps && 'torch' in caps) {
      torchBtn.style.display = '';
      torchBtn.textContent = 'Toggle light';
    } else {
      torchBtn.style.display = 'none';
    }
  }

  async function toggleTorch() {
    const track = getActiveVideoTrack();
    if (!track || !track.applyConstraints) return;
    const caps = track.getCapabilities ? track.getCapabilities() : {};
    if (!('torch' in caps)) return;
    torchOn = !torchOn;
    try {
      await track.applyConstraints({ advanced: [{ torch: torchOn }] });
    } catch { /* ignore */ }
  }

  async function tryGetUserMedia(constraints) {
    try { return await navigator.mediaDevices.getUserMedia(constraints); }
    catch { return null; }
  }

  async function startCameraPreferredBack() {
    stopStream();

    const insecure = location.protocol !== 'https:' && location.hostname !== 'localhost';
    if (insecure) {
      if (statusEl) statusEl.textContent = 'Needs HTTPS (or http://localhost) for camera.';
      return;
    }

    // 1) Try hard "environment" first (some browsers support exact)
    const attempts = [
      { video: { facingMode: { exact: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false },
      { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false },
      { video: true } // last resort
    ];

    let stream = null;
    for (const c of attempts) {
      stream = await tryGetUserMedia(c);
      if (stream) break;
    }
    if (!stream) {
      if (statusEl) statusEl.textContent = 'Could not start camera.';
      return;
    }

    // 2) If we didn't actually get the back camera, switch by deviceId if we can identify a rear camera by label
    video.srcObject = stream;
    await video.play();

    // After permission, labels become available
    await listCams();
    const currentTrack = getActiveVideoTrack();
    const sett = currentTrack?.getSettings?.() || {};
    const alreadyBack = (sett.facingMode || '').toLowerCase() === 'environment';

    if (!alreadyBack && cams.length) {
      // Prefer a device whose label hints "back/rear/environment"
      const rear = cams.find(d => isBackLabel(d.label)) || cams.find(d => /camera\s*[\d]/i.test(d.label));
      if (rear && rear.deviceId && rear.deviceId !== sett.deviceId) {
        // switch to that device
        stopStream();
        const s2 = await tryGetUserMedia({
          video: { deviceId: { exact: rear.deviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } },
          audio: false
        });
        if (s2) {
          stream = s2;
          video.srcObject = stream;
          await video.play();
        } else {
          // if switching failed, restore original
          video.srcObject = stream;
          await video.play();
        }
      }
    }

    await waitForVideoReady(video);

    canvas.width  = video.videoWidth  || 640;
    canvas.height = video.videoHeight || 480;

    setupTorchUI();

    if (statusEl) statusEl.textContent = 'Point camera at a QR‚Ä¶';
    handled = false;
    scanning = true;
    scanLoop();
  }

  async function scanLoop(){
    if (!scanning || handled) return;

    try{
      if (detector) {
        const res = await detector.detect(video);
        if (res && res.length) {
          for (const r of res) {
            const id = extractContainerId(r.rawValue);
            if (id) return onResult(id);
          }
        }
      }

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      if (window.jsQR) {
        const code = jsQR(img.data, img.width, img.height, { inversionAttempts: 'attemptBoth' });
        if (code) {
          const id = extractContainerId(code.data);
          if (id) return onResult(id);
        }
      }
    }catch(_){}

    setTimeout(scanLoop, 100);
  }

  function onResult(id){
    handled = true;
    scanning = false;
    if (statusEl) statusEl.textContent = 'Opening ' + id + '‚Ä¶';

    if (window.qrScanHook) {
      const cb = window.qrScanHook; window.qrScanHook = null;
      try { cb(id); } finally {}
      return;
    }
    location.href = '/container/' + id;
  }

  function openModal(){
    hideOtherModals();
    modal.style.zIndex = '5000';
    const dd = document.getElementById('menuDropdown');
    if (dd && !dd.hidden) dd.hidden = true;

    modal.style.display = 'flex';
    (async () => {
      try {
        await listCams();  // may be blank labels until after first permission
        await startCameraPreferredBack();
      } catch (err) {
        console.warn(err);
        if (statusEl) statusEl.textContent = 'Could not start camera. Check permissions/HTTPS.';
      }
    })();
  }

  function closeModal(){
    handled = false;
    scanning = false;
    torchOn = false;
    stopStream();
    modal.style.display = 'none';
    restoreHiddenModals();
    window.dispatchEvent(new Event('qr_scanner_closed'));
  }

  // export controls
  window.openQrScanner  = openModal;
  window.closeQrScanner = closeModal;

  // wire up
  openBtns.forEach(btn => btn.addEventListener('click', (e)=>{ e.preventDefault(); openModal(); }));
  closeBtn?.addEventListener('click', closeModal);
  modal?.addEventListener('click', (e)=>{ if (e.target === modal) closeModal(); });
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && modal.style.display === 'flex') closeModal(); });
  torchBtn?.addEventListener('click', toggleTorch);

  // optional: example of hooking a scan button elsewhere
  if (moveScanBtn){
    moveScanBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      window.qrScanHook = (id) => {
        try{
          const select = document.querySelector('#moveItemModal select[name="dest_container_id"]');
          if (select){
            let opt = Array.from(select.options).find(o => o.value === id);
            if (!opt){
              opt = document.createElement('option');
              opt.value = id;
              opt.textContent = `#${id} (scanned)`;
              select.prepend(opt);
            }
            select.value = id;
          }
          const form = document.getElementById('moveItemForm');
          if (form) form.submit();
        } finally { closeModal(); }
      };
      openModal();
    });
  }
})();
</script>




</html>