{% extends "base.html" %}
{% block content %}

<!-- Back rail + header -->
<div class="section header-row-outside">
  <a class="back-rail" href="/types" aria-label="Back" title="Back">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M15 18L9 12l6-6" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </a>

  <div class="card">
    <div class="card-pad">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h2 style="margin:.3rem 0 0 0">{{ t['name'] }}</h2>
        <div class="row" style="gap:8px;">
          <button class="icon-btn plus" id="addFieldBtn" title="Add field">
            <img class="ico" src="/static/Add.png" alt="">
          </button>
          <form class="needs-confirm"
                action="/types/{{ t['id'] }}/delete"
                method="post"
                data-confirm="Delete item type “{{ t['name'] }}” and ALL its fields? This cannot be undone.">
            <button class="icon-btn danger" title="Delete type" aria-label="Delete type">
              <img class="ico" src="/static/W_Delete.png" alt="">
            </button>
          </form>

        </div>
      </div>
    </div>
  </div>
</div>

<!-- Fields -->
<div class="section">
  <div class="row toolbar-mini" style="justify-content:space-between; align-items:center;">
    <div class="kicker">Fields</div>
  </div>

  <ul class="cards fields-list">

    {% for f in fields %}
    <li class="card field-card" data-fid="{{ f['id'] }}" draggable="true">
    <div class="card-pad">
        <div class="field-row">
        <!-- LEFT: compact vertical stack (badge above, handle below) -->


        <!-- MIDDLE: edit form (unchanged fields, no Order input) -->
        <form action="/fields/{{ f['id'] }}/update" method="post" class="field-grid">
            <input type="hidden" name="type_id" value="{{ t['id'] }}">
            <div class="order-cell">
                <span class="order-badge" data-order="{{ f['ord'] }}">{{ f['ord'] }}</span>
                <button type="button" class="icon-btn drag-handle" title="Drag to reorder" aria-label="Drag to reorder">
                  <img class="ico" src="/static/Drag.png" alt="">
                </button>
            </div>
            <label class="label">
            <span class="muted">Label</span>
            <input required name="label" value="{{ f['label'] }}">
            </label>

            <label class="kind">
            <span class="muted">Kind</span>
            <select name="kind" class="kind-select">
                <option value="text"     {% if f['kind']=='text' %}selected{% endif %}>text</option>
                <option value="number"   {% if f['kind']=='number' %}selected{% endif %}>number</option>
                <option value="select"   {% if f['kind']=='select' %}selected{% endif %}>select</option>
                <option value="date"     {% if f['kind']=='date' %}selected{% endif %}>date</option>
                <option value="checkbox" {% if f['kind']=='checkbox' %}selected{% endif %}>checkbox</option>
            </select>
            </label>

            <label class="options opt-wrap">
            <span class="muted">Options (comma, for select)</span>
            <input name="options" value="{% if f['kind']=='select' and f['options'] %}{{ f['options']|join(', ') }}{% endif %}">
            </label>

            <label class="required">
            <span class="muted">Required</span>
            <input type="checkbox" name="required" value="1" {% if f['required'] %}checked{% endif %}>
            </label>

            <div class="actions">
            <button class="icon-btn primary" type="submit" title="Save" aria-label="Save">
              <img class="ico" src="/static/Save.png" alt="">
            </button>
            </div>
        </form>

        <!-- RIGHT: delete -->
        <form class="needs-confirm delete-cell"
              action="/fields/{{ f['id'] }}/delete"
              method="post"
              data-confirm="Delete field “{{ f['label'] }}” from type “{{ t['name'] }}”?">
          <input type="hidden" name="type_id" value="{{ t['id'] }}">
          <button class="icon-btn danger" title="Delete field" aria-label="Delete field">
            <img class="ico" src="/static/W_Delete.png" alt="">
          </button>
        </form>

        </div>
    </div>
    </li>

    {% else %}
      <li class="card"><div class="card-pad"><div class="empty">No fields yet. Click <strong>+</strong> to add one.</div></div></li>
    {% endfor %}
  </ul>
</div>

<!-- Modal: Add Field -->
<div id="addFieldModal" class="modal modal-small">
  <div class="modal-content card">
    <div class="card-pad">
      <h2 class="kicker">Add field</h2>
      <form action="/types/{{ t['id'] }}/fields" method="post" class="stack">
        <label>Label
          <input required name="label" placeholder="e.g., Connector type">
        </label>

        <label>Kind
          <select name="kind" id="addKindSelect">
            <option value="text">text</option>
            <option value="number">number</option>
            <option value="select">select</option>
            <option value="date">date</option>
            <option value="checkbox">checkbox</option>
          </select>
        </label>

        <label id="addOptionsWrap" style="display:none;">Options (comma separated)
          <input name="options" placeholder="e.g., USB-A, USB-C, Micro-USB">
        </label>

        <label class="stack-field" style="min-width:150px;">
        <span>Required</span>
        <input type="checkbox" name="required" value="1" class="chk">
        </label>

        <div class="row" style="gap:8px; justify-content:flex-end;">
          <button type="button" class="ghost" id="cancelAddField">Cancel</button>
          <button class="primary">Add</button>
        </div>
      </form>
    </div>
  </div>
</div>

<script>

(function(){
  const modal = document.getElementById('confirmModal');
  if(!modal) return;

  const msgEl  = document.getElementById('confirmMsg');
  const okBtn  = document.getElementById('confirmOk');
  const cancel = document.getElementById('confirmCancel');
  let pendingForm = null;

  function open(msg){ msgEl.textContent = msg || 'Are you sure?'; modal.style.display='flex'; }
  function close(){ modal.style.display='none'; pendingForm=null; }

  modal.addEventListener('click', e=>{ if(e.target===modal) close(); });
  cancel.addEventListener('click', close);
  window.addEventListener('keydown', e=>{ if(e.key==='Escape') close(); });

  okBtn.addEventListener('click', ()=>{ if(pendingForm){ pendingForm.submit(); } close(); });

  document.querySelectorAll('form.needs-confirm').forEach(form=>{
    form.addEventListener('submit', (e)=>{
      if(form.dataset.confirmed==='1') return;
      e.preventDefault();
      pendingForm = form;
      open(form.dataset.confirm || 'Are you sure you want to delete this?');
    }, { capture:true });
  });
})();


  // Add Field modal open/close
  const addFieldBtn   = document.getElementById('addFieldBtn');
  const addFieldModal = document.getElementById('addFieldModal');
  const cancelAddField= document.getElementById('cancelAddField');
  if(addFieldBtn){ addFieldBtn.addEventListener('click', ()=> addFieldModal.style.display='flex'); }
  if(cancelAddField){ cancelAddField.addEventListener('click', ()=> addFieldModal.style.display='none'); }
  if(addFieldModal){ addFieldModal.addEventListener('click', (e)=>{ if(e.target===addFieldModal) addFieldModal.style.display='none'; }); }

  // Show Options only when Kind=select (Add Field modal)
  const addKindSelect  = document.getElementById('addKindSelect');
  const addOptionsWrap = document.getElementById('addOptionsWrap');
  if(addKindSelect){
    const syncAdd = ()=> addOptionsWrap.style.display = (addKindSelect.value === 'select') ? '' : 'none';
    addKindSelect.addEventListener('change', syncAdd); syncAdd();
  }

  // Inline rows: show Options only when Kind=select
  document.querySelectorAll('.field-row').forEach(row=>{
    const kindSel = row.querySelector('.kind-select');
    const optWrap = row.querySelector('.opt-wrap');
    if(!kindSel || !optWrap) return;
    const sync = ()=> { optWrap.style.display = (kindSel.value === 'select') ? '' : 'none'; };
    kindSel.addEventListener('change', sync);
    // init from current selection
    sync();
  });

  // Esc closes modal
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Escape'){ if(addFieldModal) addFieldModal.style.display='none'; }
  });

  // Show Options only when Kind=select for inline rows
  document.querySelectorAll('.field-card').forEach(card=>{
    const kindSel = card.querySelector('.kind-select');
    const optWrap = card.querySelector('.opt-wrap');
    if(kindSel && optWrap){
      const sync = ()=> optWrap.style.display = (kindSel.value === 'select') ? '' : 'none';
      kindSel.addEventListener('change', sync); sync();
    }
  });

  // Drag & drop reorder (desktop)
  (function(){
    const list = document.querySelector('.fields-list');
    if(!list) return;
    const TYPE_ID = "{{ t['id'] }}";

    let dragEl = null;
    let armDrag = false;    // only allow drag when handle pressed

    // Arm dragging only when pressing the handle
    list.addEventListener('mousedown', (e)=>{
      if (e.target.closest('.drag-handle')) armDrag = true;
    });
    list.addEventListener('mouseup', ()=> armDrag = false);
    list.addEventListener('mouseleave', ()=> armDrag = false);

    list.addEventListener('dragstart', (e)=>{
      const card = e.target.closest('.field-card');
      if(!card) return e.preventDefault();
      if(!armDrag) return e.preventDefault();     // must start from handle
      dragEl = card;
      card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      // FF needs data
      e.dataTransfer.setData('text/plain', card.dataset.fid);
      // Optional: smaller ghost
      // const img = new Image(); img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBA=='; e.dataTransfer.setDragImage(img, 0, 0);
    });

    list.addEventListener('dragend', ()=>{
      if(dragEl){ dragEl.classList.remove('dragging'); dragEl = null; }
      armDrag = false;
      persistOrder();
    });

    list.addEventListener('dragover', (e)=>{
      if(!dragEl) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      const after = getDragAfterElement(list, e.clientY);
      if(after == null) list.appendChild(dragEl);
      else list.insertBefore(dragEl, after);
    });

    function getDragAfterElement(container, y){
      const els = [...container.querySelectorAll('.field-card:not(.dragging)')];
      let closest = {offset: Number.NEGATIVE_INFINITY, element: null};
      for(const el of els){
        const box = el.getBoundingClientRect();
        const offset = y - (box.top + box.height/2);
        if(offset < 0 && offset > closest.offset){
          closest = {offset, element: el};
        }
      }
      return closest.element;
    }

    async function persistOrder(){
      const ids = [...list.querySelectorAll('.field-card')].map(li => li.dataset.fid);
      // update badges immediately
      [...list.querySelectorAll('.field-card .order-badge')].forEach((b,i)=>{
        b.textContent = i+1; b.setAttribute('data-order', i+1);
      });
      try{
        await fetch(`/types/${TYPE_ID}/fields/reorder`, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({order: ids})
        });
      }catch(e){
        console.warn('Reorder failed', e);
      }
    }
  })();


</script>
<script>
/* ---------- Mobile (touch) drag & drop reorder via Pointer Events ---------- */
(function(){
  const list = document.querySelector('.fields-list');
  if(!list) return;

  // Only enable when device uses coarse pointer (touch) — keeps desktop DnD unchanged
  const isTouch = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
  if (!isTouch) return;

  const TYPE_ID = "{{ t['id'] }}";

  let dragging = null;       // the .field-card being moved
  let placeholder = null;    // spacer element in the list
  let startY = 0, offsetY = 0;

  list.addEventListener('pointerdown', (e)=>{
    const handle = e.target.closest('.drag-handle');
    if(!handle) return;
    window._autoScrollStart && window._autoScrollStart(e.clientY);   // <— add
    const card = handle.closest('.field-card');
    if(!card) return;



    e.preventDefault();
    handle.setPointerCapture(e.pointerId);

    // Prepare placeholder same height as card
    const rect = card.getBoundingClientRect();
    placeholder = document.createElement('li');
    placeholder.className = 'card field-card placeholder';
    placeholder.style.height = rect.height + 'px';

    // Insert placeholder after the card and float the card
    card.classList.add('touch-dragging');
    card.style.width = rect.width + 'px';
    card.style.position = 'fixed';
    card.style.left = rect.left + 'px';
    card.style.top  = rect.top  + 'px';
    card.style.zIndex = 1000;
    card.style.pointerEvents = 'none';

    card.after(placeholder);

    dragging = card;
    startY = e.clientY;
    offsetY = e.clientY - rect.top;

    // Listen on the list so we can move while finger drags
    list.addEventListener('pointermove', onMove);
    list.addEventListener('pointerup', onUp, { once:true });
    list.addEventListener('pointercancel', onUp, { once:true });
  });

  function onMove(e){
    if(!dragging) return;
    e.preventDefault();

    window._autoScrollUpdate && window._autoScrollUpdate(e.clientY); // <— add


    // Move the floating card
    const newTop = e.clientY - offsetY;
    dragging.style.top = newTop + 'px';

    // Find insert position for placeholder
    const after = getAfterElement(list, e.clientY);
    if(after == null) list.appendChild(placeholder);
    else list.insertBefore(placeholder, after);
  }

  async function onUp(e){
    // Drop: put the card where the placeholder is
    if(dragging && placeholder){
      placeholder.replaceWith(dragging);
      dragging.classList.remove('touch-dragging');
      Object.assign(dragging.style, {position:'', left:'', top:'', width:'', zIndex:'', pointerEvents:''});
      window._autoScrollStop && window._autoScrollStop(); 
    }

    dragging = null;
    placeholder = null;

    list.removeEventListener('pointermove', onMove);

    // Persist new order
    const ids = [...list.querySelectorAll('.field-card')].map(li => li.dataset.fid);
    // Update badges immediately
    [...list.querySelectorAll('.field-card .order-badge')].forEach((b,i)=>{
      b.textContent = i+1; b.setAttribute('data-order', i+1);
    });
    try{
      await fetch(`/types/${TYPE_ID}/fields/reorder`, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({order: ids})
      });
    }catch(err){
      console.warn('Reorder failed', err);
    }
  }

  // Find the element that should come after the dragged card based on pointer Y
  function getAfterElement(container, y){
    const els = [...container.querySelectorAll('.field-card:not(.touch-dragging)')];
    let closest = {offset: Number.NEGATIVE_INFINITY, el: null};
    for(const el of els){
      const box = el.getBoundingClientRect();
      const offset = y - (box.top + box.height/2);
      if(offset < 0 && offset > closest.offset){
        closest = {offset, el};
      }
    }
    return closest.el;
  }
})();
</script>
<script>
/* ===== Auto-scroll while reordering (desktop + mobile) ===== */
(function(){
  const list = document.querySelector('.fields-list');
  if(!list) return;

  // Find scrollable container; fall back to window
  function getScrollParent(el){
    let p = el.parentElement;
    while(p){
      const s = getComputedStyle(p);
      const canScroll = /(auto|scroll)/.test(s.overflowY) && p.scrollHeight > p.clientHeight;
      if(canScroll) return p;
      p = p.parentElement;
    }
    return window;
  }

  const scrollEl = getScrollParent(list);
  let rafId = null;
  let lastClientY = null;

  function step(){
    rafId = requestAnimationFrame(step);
    if(lastClientY == null) return;

    const EDGE = 80;         // px from top/bottom to start autoscroll
    const MAX = 18;          // max px per frame (~1080px/s @60fps)

    const rect = (scrollEl === window)
      ? { top: 0, bottom: innerHeight }
      : scrollEl.getBoundingClientRect();

    let speed = 0;
    const distTop    = lastClientY - rect.top;
    const distBottom = rect.bottom - lastClientY;

    if (distTop < EDGE) {
      speed = -((EDGE - distTop) / EDGE) * MAX;
    } else if (distBottom < EDGE) {
      speed =  ((EDGE - distBottom) / EDGE) * MAX;
    }

    if (Math.abs(speed) > 0.2) {
      if (scrollEl === window) window.scrollBy(0, speed);
      else scrollEl.scrollTop += speed;

      // While scrolling on touch, keep placeholder position in sync
      if (typeof window._touchRepositionPlaceholder === 'function') {
        window._touchRepositionPlaceholder(lastClientY);
      }
    }
  }

  function startAutoScroll(y){
    lastClientY = y;
    if(rafId == null) rafId = requestAnimationFrame(step);
  }
  function updateAutoScroll(y){ lastClientY = y; }
  function stopAutoScroll(){
    lastClientY = null;
    if(rafId != null){ cancelAnimationFrame(rafId); rafId = null; }
  }

  // Desktop HTML5 DnD: track pointer Y during dragover
  document.addEventListener('dragover', (e)=>{
    if(!e.target.closest('.fields-list')) return;
    startAutoScroll(e.clientY);
  }, {passive:false});
  document.addEventListener('dragend', stopAutoScroll);
  document.addEventListener('drop',    stopAutoScroll);

  // Expose for touch fallback script
  window._autoScrollStart  = startAutoScroll;
  window._autoScrollUpdate = updateAutoScroll;
  window._autoScrollStop   = stopAutoScroll;
})();


/* Mobile: inline actions + "More" and move Delete into actions (≤640px) */
(function(){
  const mq = window.matchMedia('(max-width: 640px)');

  function applyMobileUI(){
    document.querySelectorAll('.fields-list .field-row').forEach(row=>{
      const form = row.querySelector('.field-grid');
      if(!form) return;

      // Ensure an actions container exists
      let actions = form.querySelector('.actions');
      if(!actions){
        actions = document.createElement('div');
        actions.className = 'actions';
        form.appendChild(actions);
      }

      // Ensure the "More" button exists on mobile
      let moreBtn = actions.querySelector('.more-btn');
      if(mq.matches){
        if(!moreBtn){
          moreBtn = document.createElement('button');
          moreBtn.type = 'button';
          moreBtn.className = 'icon-btn more more-btn';
          moreBtn.innerHTML = '<img src="/static/More.png" alt="">';
          moreBtn.title = 'More';
          moreBtn.setAttribute('aria-expanded','false');
          moreBtn.addEventListener('click', ()=>{
            form.classList.toggle('show-extras');
            const exp = form.classList.contains('show-extras');
            moreBtn.setAttribute('aria-expanded', exp ? 'true' : 'false');
          });
          // Place "More" to the left of Save so both fit
          actions.insertBefore(moreBtn, actions.firstChild);
        }
      }else{
        if(moreBtn) moreBtn.remove();
        form.classList.remove('show-extras');
      }

      // Move Delete into actions on mobile; put it back on desktop
      const deleteForm = row.querySelector('.delete-cell');
      if(deleteForm){
        if(mq.matches){
          if(deleteForm.parentElement !== actions){
            actions.appendChild(deleteForm);        // inline with Save/More
          }
        }else{
          if(deleteForm.parentElement !== row){
            row.appendChild(deleteForm);            // back to row end on desktop
          }
        }
      }
    });
  }

  applyMobileUI();
  mq.addEventListener('change', applyMobileUI);
})();


</script>

{% endblock %}
